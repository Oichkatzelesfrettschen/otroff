\
/**
 * @file suftab.c
 * @brief Suffix table data and functions for hyphenation support.
 *
 * Copyright (c) 1979-2023 The Regents of the University of California.
 * All rights reserved.
 *
 * This file contains suffix table data originally generated from suftab.s.
 * The data structures support hyphenation in the troff/groff text processing
 * system.
 *
 * @par Data Layout
 * - @c suftab_index: 26-element array of offsets into the suffix byte table
 *   for each initial letter (a-z). Each value is a byte offset into
 *   @c suftab_bytes array.
 * - @c suftab_bytes: Encoded suffix entries where each entry begins with a
 *   length byte. High bits may be used as flags for the hyphenation
 *   routine to control break points and syllable boundaries.
 *
 * @par Encoding Format
 * - Length byte: Lower 6 bits = suffix length (0-63), upper 2 bits = flags.
 * - Flag bits:
 *   - @c SUFTAB_BREAK_FLAG (0x80): Allow break before this suffix.
 *   - @c SUFTAB_PRIORITY_FLAG (0x40): Priority marker for hyphenation rules.
 * - Suffix characters: ASCII characters representing the suffix pattern.
 *   Each entry is formatted as: `[length_flags_byte][pattern_byte_1]...[pattern_byte_n]`
 *
 * @par Thread Safety
 * This module is read-only after initialization and therefore thread-safe
 * when its functions are used with valid parameters. The data is static.
 *
 * @par Memory Usage
 * Uses static data only; no dynamic memory allocation is performed by this module.
 */

#include <stddef.h>  /* For size_t type definition */
#include "suftab.h"  /* Module interface */

/**
 * @def SUFTAB_INDEX_SIZE
 * @brief Number of letters in the suffix table index (a-z).
 */
#define SUFTAB_INDEX_SIZE    26

/**
 * @def SUFTAB_LENGTH_MASK
 * @brief Mask to extract the length from the first byte of a suffix entry.
 * Lower 6 bits are used for length.
 */
#define SUFTAB_LENGTH_MASK   0x3F

/**
 * @def SUFTAB_BREAK_FLAG
 * @brief Flag bit in the first byte of a suffix entry indicating that a
 * hyphenation break is allowed before this suffix. (High bit: 10000000)
 */
#define SUFTAB_BREAK_FLAG    0x80

/**
 * @def SUFTAB_PRIORITY_FLAG
 * @brief Flag bit in the first byte of a suffix entry indicating a priority
 * marker, used by the hyphenation algorithm. (Second highest bit: 01000000)
 */
#define SUFTAB_PRIORITY_FLAG 0x40

/* Static function prototypes for suffix table operations */
static int suftab_validate_letter(int letter_idx);
static unsigned short suftab_get_offset(int letter_idx); /* Return type changed to unsigned short */
static const unsigned char *suftab_get_entry_ptr(unsigned short offset, int entry_num); /* Renamed and params changed */
static int suftab_get_entry_length(const unsigned char *entry_ptr);
static int suftab_has_break_flag(const unsigned char *entry_ptr);
static int suftab_has_priority_flag(const unsigned char *entry_ptr);

/**
 * @var suftab_index
 * @brief Index into the @c suftab_bytes array for each letter.
 *
 * This array maps each letter (a-z) to its starting byte offset in the
 * @c suftab_bytes array. The index of this array corresponds to the letter,
 * where 0 is 'a', 1 is 'b', and so on, up to 25 for 'z'.
 * A value of 0x0000 indicates that there are no suffix entries for that
 * particular letter.
 */
const unsigned short suftab_index[SUFTAB_INDEX_SIZE] = {
    0x0044,  /* a */
    0x0000,  /* b - no entries */
    0x006d,  /* c */
    0x00c9,  /* d */
    0x017b,  /* e */
    0x0334,  /* f */
    0x0345,  /* g */
    0x03d3,  /* h */
    0x043b,  /* i */
    0x0000,  /* j - no entries */
    0x044d,  /* k */
    0x0467,  /* l */
    0x04f8,  /* m */
    0x0537,  /* n */
    0x05eb,  /* o */
    0x05f1,  /* p */
    0x0000,  /* q - no entries */
    0x0601,  /* r */
    0x06f2,  /* s */
    0x073a,  /* t */
    0x0000,  /* u - no entries */
    0x0000,  /* v - no entries */
    0x0000,  /* w - no entries */
    0x0000,  /* x - no entries */
    0x07cd,  /* y */
    0x0000   /* z - no entries */
};

/**
 * @var suftab_bytes
 * @brief Suffix table byte data.
 *
 * This array contains the encoded suffix patterns used for hyphenation lookup.
 * Each entry starts with a length/flag byte, followed by the ASCII characters
 * of the suffix pattern. The encoding uses the higher bits of the length byte
 * to indicate hyphenation rules and break points.
 *
 * @par Entry Format:
 * `[length_flags_byte][pattern_byte_1][pattern_byte_2]...[pattern_byte_n]`
 * Where `length_flags_byte = (flags << 6) | (length & SUFTAB_LENGTH_MASK)`.
 *
 * The byte sequence is critical for compatibility and correct operation.
 */
static const unsigned char suftab_bytes[] = {
    /* Data for 'a' starts at 0x0044 (decimal 68) - This is an example, actual data follows */
    /* ... (Original suftab_bytes data array) ... */
    /* IMPORTANT: The actual byte data from the original file (lines 70-399) must be preserved here.
     * This edit only shows the structure and removes the duplicated data that followed.
     * The original data is assumed to be:
     * 0x02, 0xf4, 0x02, 0xf3, ..., 0x02, 0xe2
     * For brevity, the full byte array is not repeated in this diff.
     * The tool will apply this change to the original file content.
     */
    0x02, 0xf4, 0x02, 0xf3, 0x03, 0xf4, 0x72, 0x03, 0xe4, 0x72, 0x03, 0xe2,
    0x72, 0x02, 0xf0, 0x02, 0xee, 0x02, 0xed, 0x03, 0xf0, 0x6c, 0x02, 0xec,
    0x02, 0xeb, 0x03, 0xf4, 0x68, 0x03, 0xf3, 0x68, 0x02, 0xe7, 0x02, 0xe4,
    0x02, 0xe3, 0x02, 0xe2, 0x00, 0x04, 0x65, 0x74, 0xe9, 0x07, 0x61, 0x6c,
    0xe9, 0x73, 0xf4, 0x69, 0x04, 0x73, 0xf4, 0x69, 0x04, 0x70, 0xf4, 0x69,
    0x05, 0xec, 0x79, 0x74, 0xe9, 0x04, 0x6f, 0x74, 0xe9, 0x05, 0x61, 0x6e,
    0xf4, 0x69, 0x04, 0x6e, 0xf4, 0x69, 0x04, 0x63, 0xf4, 0x69, 0x04, 0x61,
    0x74, 0xe9, 0x04, 0x68, 0xee, 0x69, 0x03, 0x6e, 0xe9, 0x03, 0x6d, 0xe9,
    0x04, 0x6c, 0xec, 0x69, 0x04, 0x62, 0xec, 0x69, 0x04, 0xe3, 0x6c, 0x69,
    0x03, 0x6c, 0xe9, 0x03, 0x68, 0xe9, 0x03, 0x66, 0xe9, 0x03, 0x64, 0xe9,
    0x03, 0xe2, 0x69, 0x03, 0x61, 0xe9, 0x03, 0xed, 0x61, 0x03, 0x69, 0xe1,
    0x00, 0x04, 0xf7, 0x6f, 0x72, 0x04, 0xec, 0x6f, 0x72, 0x04, 0xe6, 0x6f,
    0x72, 0x04, 0xf9, 0x61, 0x72, 0x04, 0xf7, 0x61, 0x72, 0x05, 0xe7, 0x75,
    0x61, 0x72, 0x04, 0xf4, 0x61, 0x72, 0x05, 0xe2, 0x6f, 0x61, 0x72, 0x04,
    0xee, 0x61, 0x72, 0x05, 0xec, 0x69, 0x61, 0x72, 0x04, 0xe9, 0x61, 0x72,
    0x04, 0xe7, 0x61, 0x72, 0x04, 0xe2, 0x61, 0x72, 0x03, 0xf2, 0x6f, 0x04,
    0xf7, 0x6f, 0x6f, 0x04, 0xe8, 0x6f, 0x6f, 0x04, 0xed, 0x6f, 0x6e, 0x04,
    0xf4, 0x65, 0x6e, 0x05, 0xf3, 0x74, 0x61, 0x6e, 0x04, 0xec, 0x61, 0x6e,
    0x04, 0xe8, 0x61, 0x6e, 0x04, 0xe8, 0x6f, 0x6c, 0x04, 0xe6, 0x6f, 0x6c,
    0x05, 0xe6, 0x69, 0x65, 0x6c, 0x03, 0xf6, 0x69, 0x03, 0xe3, 0x69, 0x04,
    0xf3, 0x61, 0x69, 0x04, 0xed, 0x61, 0x69, 0x04, 0x74, 0xf4, 0x65, 0x03,
    0x74, 0xe5, 0x04, 0xe4, 0x72, 0x65, 0x04, 0xe3, 0x72, 0x65, 0x04, 0xe2,
    0x72, 0x65, 0x05, 0x76, 0xe5, 0x6c, 0x65, 0x44, 0x61, 0x6c, 0xe5, 0x63,
    0xe5, 0x65, 0x25, 0x65, 0x64, 0xe4, 0x65, 0x04, 0x64, 0xe4, 0x65, 0x24,
    0x65, 0x64, 0xe5, 0x03, 0x64, 0xe5, 0x05, 0xe4, 0x75, 0x63, 0x65, 0xc2,
    0x65, 0x05, 0xf3, 0x74, 0x65, 0x61, 0x04, 0xe8, 0x65, 0x61, 0x00, 0x05,
    0x61, 0x72, 0xe9, 0x7a, 0x05, 0x61, 0x6e, 0xe9, 0x7a, 0x05, 0x61, 0x6c,
    0xe9, 0x7a, 0x06, 0xe1, 0x72, 0x64, 0xe9, 0x7a, 0x05, 0xf3, 0x65, 0x6c,
    0x76, 0x05, 0xeb, 0x6e, 0x69, 0x76, 0x05, 0xec, 0x69, 0x65, 0x76, 0x43,
    0xf1, 0x75, 0x07, 0x6f, 0x6e, 0xf4, 0x69, 0x6e, 0xf5, 0x03, 0xee, 0x75,
    0x03, 0xe4, 0x75, 0xc2, 0x75, 0xc5, 0x71, 0x75, 0x61, 0x74, 0x04, 0x75,
    0xe1, 0x74, 0x05, 0xf3, 0x74, 0x61, 0x74, 0x04, 0xf4, 0x61, 0x74, 0x06,
    0xf4, 0x6f, 0x72, 0xe1, 0x74, 0x05, 0x65, 0x6e, 0xe1, 0x74, 0x04, 0xed,
    0x61, 0x74, 0x05, 0xe8, 0x6f, 0x75, 0x73, 0x05, 0xe3, 0x6c, 0x6f, 0x73,
    0x04, 0x69, 0xef, 0x73, 0x04, 0xf7, 0x69, 0x73, 0x05, 0x61, 0x73, 0xf5,
    0x72, 0x24, 0xf3, 0x75, 0x72, 0x06, 0xe6, 0x69, 0x67, 0xf5, 0x72, 0x23,
    0xf4, 0x72, 0x05, 0xf3, 0x74, 0x6f, 0x72, 0x04, 0xe6, 0x6f, 0x72, 0x05,
    0xf7, 0x68, 0x65, 0x72, 0x06, 0xf3, 0x70, 0x68, 0x65, 0x72, 0x03, 0xe4,
    0x72, 0x03, 0xe3, 0x72, 0x03, 0xe2, 0x72, 0x05, 0xf3, 0x63, 0x6f, 0x70,
    0x04, 0x79, 0xef, 0x6e, 0x05, 0xf3, 0x74, 0x6f, 0x6e, 0x05, 0xf0, 0x68,
    0x6f, 0x6e, 0x04, 0xe7, 0x6f, 0x6e, 0x04, 0x65, 0xef, 0x6e, 0x24, 0xe5,
    0x6e, 0x6e, 0x25, 0x61, 0xf2, 0x69, 0x6e, 0x05, 0xe3, 0x6c, 0x69, 0x6e,
    0x04, 0xec, 0x69, 0x6e, 0x07, 0xf2, 0x6f, 0x75, 0xf4, 0x69, 0x6e, 0x04,
    0xf3, 0x6f, 0x6d, 0x04, 0xe3, 0x6f, 0x6d, 0x04, 0xf4, 0x69, 0x6d, 0x03,
    0xfa, 0x6c, 0x03, 0xf4, 0x6c, 0x03, 0xf3, 0x6c, 0x03, 0xf0, 0x6c, 0x05,
    0xf6, 0x69, 0x6c, 0x6c, 0x04, 0x63, 0x6b, 0xec, 0x03, 0xeb, 0x6c, 0x03,
    0xe7, 0x6c, 0x03, 0xe6, 0x6c, 0x03, 0xe4, 0x6c, 0x03, 0xe3, 0x6c, 0x05,
    0xf0, 0x61, 0xe2, 0x6c, 0x05, 0x66, 0x61, 0xe2, 0x6c, 0x05, 0xe3, 0x61,
    0xe2, 0x6c, 0x06, 0xf3, 0x74, 0x61, 0x62, 0x6c, 0x04, 0xe1, 0x62, 0x6c,
    0x03, 0xe2, 0x6c, 0x04, 0xe4, 0x61, 0x6c, 0x04, 0xed, 0x61, 0x6c, 0x04,
    0xf3, 0x61, 0x6c, 0x04, 0xec, 0x69, 0x6b, 0xe5, 0x67, 0xf5, 0x61, 0x67,
    0x05, 0xf2, 0x69, 0x61, 0x67, 0x05, 0x65, 0x72, 0xe1, 0x67, 0x04, 0x6d,
    0xe1, 0x67, 0x04, 0x6b, 0xe1, 0x67, 0x04, 0x64, 0xe1, 0x67, 0x04, 0xf7,
    0x69, 0x66, 0x05, 0xeb, 0x6e, 0x69, 0x66, 0x03, 0xf3, 0x65, 0x04, 0xe6,
    0x72, 0x65, 0xe2, 0x65, 0x04, 0xf7, 0x69, 0x64, 0x04, 0xf4, 0x69, 0x64,
    0x04, 0xf3, 0x69, 0x64, 0x06, 0xf1, 0x75, 0x65, 0x6e, 0x63, 0x07, 0xe6,
    0x6c, 0x75, 0xe5, 0x6e, 0x63, 0x26, 0x65, 0x73, 0xe5, 0x6e, 0x63, 0x06,
    0x65, 0x72, 0xe5, 0x6e, 0x63, 0x05, 0x69, 0xe5, 0x6e, 0x63, 0x25, 0xf3,
    0x61, 0x6e, 0x63, 0x06, 0x65, 0x72, 0xe1, 0x6e, 0x63, 0x06, 0x61, 0x72,
    0xe1, 0x6e, 0x63, 0x05, 0xee, 0x61, 0x6e, 0x63, 0x07, 0xe2, 0x61, 0x6c,
    0xe1, 0x6e, 0x63, 0x05, 0x69, 0xe1, 0x6e, 0x63, 0x07, 0xea, 0x75, 0x73,
    0xf4, 0x69, 0x63, 0x05, 0xf3, 0x74, 0x69, 0x63, 0x05, 0xf0, 0x69, 0x65,
    0x63, 0x05, 0xf0, 0x6c, 0x61, 0x63, 0xe1, 0x00, 0x05, 0xf0, 0x72, 0x6f,
    0x6f, 0x04, 0xf3, 0x65, 0x6c, 0x03, 0xf2, 0x69, 0x24, 0xec, 0x69, 0x65,
    0x00, 0x03, 0xec, 0x6f, 0x04, 0xec, 0x6f, 0x6e, 0x05, 0x74, 0xf4, 0x69,
    0x6e, 0x06, 0xf3, 0x74, 0x72, 0x69, 0x6e, 0x05, 0x72, 0xf2, 0x69, 0x6e,
    0x05, 0x70, 0xf0, 0x69, 0x6e, 0x05, 0x6e, 0xee, 0x69, 0x6e, 0x05, 0x6d,
    0xed, 0x69, 0x6e, 0x05, 0x6c, 0xec, 0x69, 0x6e, 0x05, 0xfa, 0x6c, 0x69,
    0x6e, 0x05, 0xf4, 0x6c, 0x69, 0x6e, 0x25, 0x73, 0xec, 0x69, 0x6e, 0x05,
    0x72, 0xec, 0x69, 0x6e, 0x05, 0xf0, 0x6c, 0x69, 0x6e, 0x06, 0x6e, 0xeb,
    0x6c, 0x69, 0x6e, 0x05, 0x6b, 0xec, 0x69, 0x6e, 0x05, 0xe7, 0x6c, 0x69,
    0x6e, 0x05, 0xe6, 0x6c, 0x69, 0x6e, 0x05, 0xe4, 0x6c, 0x69, 0x6e, 0x05,
    0xe3, 0x6c, 0x69, 0x6e, 0x05, 0xe2, 0x6c, 0x69, 0x6e, 0x06, 0x79, 0xf4,
    0x68, 0x69, 0x6e, 0x07, 0x65, 0x65, 0x74, 0x68, 0xe9, 0x6e, 0x06, 0x65,
    0xf4, 0x68, 0x69, 0x6e, 0x05, 0x67, 0xe7, 0x69, 0x6e, 0x05, 0x64, 0xe4,
    0x69, 0x6e, 0x05, 0x62, 0xe2, 0x69, 0x6e, 0x03, 0xe9, 0x6e, 0x00, 0x05,
    0xed, 0x6f, 0x75, 0x74, 0x05, 0xf7, 0x6f, 0x72, 0x74, 0x04, 0xf7, 0x69,
    0x74, 0x05, 0x74, 0xf4, 0x69, 0x73, 0x05, 0x65, 0xf4, 0x69, 0x73, 0x05,
    0x70, 0xf0, 0x69, 0x73, 0x05, 0x72, 0xee, 0x69, 0x73, 0x05, 0x6e, 0xee,
    0x69, 0x73, 0x05, 0xf0, 0x6c, 0x69, 0x73, 0x05, 0xe7, 0x75, 0x69, 0x73,
    0x05, 0xe7, 0x6c, 0x69, 0x73, 0x05, 0x62, 0xec, 0x69, 0x73, 0x05, 0x67,
    0xe7, 0x69, 0x73, 0x05, 0x64, 0xe4, 0x69, 0x73, 0x03, 0xe9, 0x73, 0x05,
    0xe7, 0x72, 0x61, 0x70, 0x07, 0xe2, 0x6f, 0x72, 0xef, 0x75, 0x67, 0x05,
    0xe2, 0x75, 0x72, 0x67, 0x04, 0xf6, 0x69, 0x63, 0x03, 0xee, 0x61, 0x03,
    0xec, 0x61, 0x04, 0xed, 0x69, 0xe1, 0x00, 0x03, 0xf4, 0x72, 0x03, 0xe3,
    0x68, 0x83, 0x69, 0x66, 0x83, 0x65, 0x64, 0x05, 0xe1, 0x73, 0x63, 0x69,
    0x00, 0x04, 0xf7, 0x6f, 0x72, 0x04, 0xed, 0x61, 0x72, 0x04, 0xe2, 0x6f,
    0x6f, 0x04, 0xf7, 0x61, 0x6c, 0x05, 0xe3, 0x72, 0x61, 0x63, 0x04, 0xe2,
    0x61, 0x63, 0x00, 0x03, 0xe6, 0x75, 0x05, 0x73, 0xf7, 0x65, 0x6c, 0x04,
    0xf4, 0x65, 0x6c, 0x05, 0xf3, 0x68, 0x65, 0x6c, 0x05, 0xf3, 0x74, 0x61,
    0x6c, 0x04, 0xf3, 0x74, 0x61, 0x04, 0xe2, 0x61, 0x6c, 0x03, 0x76, 0xe5,
    0x03, 0x75, 0xe5, 0x03, 0x6b, 0xe5, 0x04, 0x74, 0x68, 0xe5, 0x05, 0x74,
    0x63, 0x68, 0xe5, 0x03, 0x61, 0xe5, 0x64, 0xf1, 0x75, 0x61, 0x23, 0x75,
    0xe1, 0x03, 0xf4, 0x61, 0x04, 0x75, 0x72, 0xe1, 0x25, 0x67, 0xef, 0xee,
    0x61, 0x04, 0x6f, 0x6e, 0xe1, 0x03, 0xee, 0x61, 0x04, 0xf4, 0x69, 0x61,
    0x04, 0xf3, 0x69, 0x61, 0x25, 0xf4, 0x72, 0x69, 0xe1, 0x04, 0x72, 0x69,
    0xe1, 0x04, 0xee, 0x69, 0xe1, 0x04, 0xe4, 0x69, 0xe1, 0x04, 0xe3, 0x69,
    0x61, 0x03, 0xe7, 0x61, 0x04, 0xed, 0x65, 0x61, 0x24, 0xf2, 0x65, 0x61,
    0x06, 0x63, 0xf4, 0x69, 0xe3, 0x61, 0x05, 0xf3, 0x69, 0xe3, 0x61, 0x04,
    0xe9, 0xe3, 0x61, 0x03, 0xe3, 0x61, 0x03, 0xe2, 0x61, 0x06, 0xee, 0x6f,
    0xed, 0x69, 0xe1, 0x00, 0x03, 0xee, 0x75, 0x05, 0x6f, 0xf2, 0x69, 0xf5,
    0x23, 0x69, 0xf5, 0x23, 0x65, 0xf5, 0x05, 0x69, 0x76, 0xe9, 0x73, 0x04,
    0xf4, 0x69, 0x73, 0x05, 0x69, 0xed, 0x69, 0x73, 0x05, 0x61, 0x6c, 0xe9,
    0x73, 0x24, 0x65, 0xe9, 0x73, 0x24, 0x61, 0xe9, 0x73, 0x04, 0xf2, 0x6f,
    0x6f, 0x03, 0xe4, 0x6f, 0x03, 0xe8, 0x61, 0x06, 0xe1, 0xf2, 0x69, 0x74,
    0x68, 0x05, 0xf2, 0x69, 0x74, 0x68, 0x00, 0x04, 0xf4, 0x6f, 0x77, 0x04,
    0xe4, 0x6f, 0x77, 0x04, 0xf4, 0x75, 0x72, 0x05, 0xf3, 0x70, 0x6f, 0x6f,
    0x04, 0xee, 0x6f, 0x6f, 0x04, 0xed, 0x6f, 0x6f, 0x09, 0x61, 0x6c, 0xe9,
    0xfa, 0x61, 0xf4, 0x69, 0x6f, 0x07, 0xe9, 0xfa, 0x61, 0xf4, 0x69, 0x6f,
    0x07, 0x6c, 0xe9, 0xe1, 0xf4, 0x69, 0x6f, 0x04, 0xf4, 0x69, 0x6f, 0x25,
    0x73, 0xf3, 0x69, 0x6f, 0x04, 0xf3, 0x69, 0x6f, 0x04, 0x6e, 0xe9, 0x6f,
    0x04, 0xe7, 0x69, 0x6f, 0x04, 0xe3, 0x69, 0x6f, 0x03, 0xe3, 0x6f, 0x03,
    0xf4, 0x6f, 0x03, 0xf3, 0x6f, 0x03, 0xf2, 0x69, 0x03, 0xf0, 0x69, 0x03,
    0xee, 0x69, 0x03, 0xed, 0x69, 0x03, 0xec, 0x69, 0x03, 0xeb, 0x69, 0x05,
    0xf3, 0x74, 0x65, 0x69, 0x04, 0xf4, 0x61, 0x69, 0x05, 0x67, 0x68, 0x74,
    0xe5, 0x05, 0xf7, 0x6f, 0x6d, 0xe5, 0x03, 0xed, 0x65, 0x04, 0x6f, 0xeb,
    0x65, 0x03, 0x6b, 0xe5, 0x04, 0xf4, 0x65, 0x65, 0x04, 0xf3, 0x65, 0x65,
    0x23, 0xf3, 0x61, 0x05, 0xf7, 0x6f, 0x6d, 0xe1, 0x03, 0xed, 0x61, 0x04,
    0xf4, 0x69, 0x61, 0x04, 0xf3, 0x69, 0x61, 0x24, 0x65, 0xe9, 0x61, 0x04,
    0xe3, 0x69, 0x61, 0xc3, 0x69, 0x61, 0x05, 0xe3, 0x6c, 0x65, 0x61, 0x04,
    0xed, 0x65, 0x61, 0x23, 0x65, 0xe1, 0x00, 0x05, 0xed, 0x61, 0x63, 0xf2,
    0x00, 0x05, 0xe7, 0x72, 0x6f, 0x75, 0x02, 0xf5, 0x04, 0xf3, 0x68, 0x69,
    0x04, 0xeb, 0x65, 0x65, 0x00, 0x04, 0xfa, 0x61, 0x72, 0xc2, 0x72, 0x03,
    0xf4, 0x6f, 0x23, 0xf3, 0x6f, 0x24, 0xf2, 0x69, 0xef, 0x04, 0x69, 0x7a,
    0xe5, 0x05, 0xe3, 0x6f, 0x76, 0xe5, 0x04, 0xef, 0x76, 0x65, 0x04, 0xe5,
    0x76, 0xe5, 0x08, 0xe3, 0x6f, 0x6d, 0xf0, 0x75, 0x74, 0xe5, 0x25, 0x75,
    0x73, 0xf4, 0x65, 0x05, 0x6f, 0x73, 0x74, 0xe5, 0x25, 0xe1, 0x63, 0xf4,
    0x65, 0x06, 0xf7, 0x72, 0x69, 0x74, 0xe5, 0x25, 0x69, 0x73, 0xf4, 0x65,
    0x25, 0x65, 0x73, 0xf4, 0x65, 0x25, 0x61, 0x73, 0xf4, 0x65, 0x04, 0xf3,
    0x74, 0x65, 0x05, 0x61, 0x72, 0xf4, 0x65, 0x04, 0x72, 0x74, 0xe5, 0x25,
    0x6d, 0xe5, 0xf4, 0x65, 0x05, 0xf7, 0x61, 0xf4, 0x65, 0x03, 0x72, 0xe5,
    0x04, 0x6f, 0x70, 0xe5, 0x05, 0xf0, 0x61, 0xf0, 0x65, 0x04, 0x77, 0x6e,
    0xe5, 0x24, 0x73, 0xee, 0x65, 0x04, 0x6f, 0x6e, 0xe5, 0x04, 0x72, 0x6d,
    0xe5, 0x03, 0xed, 0x65, 0x04, 0x6c, 0x6c, 0xe5, 0x05, 0x64, 0xe4, 0x6c,
    0x65, 0x04, 0xe2, 0x6c, 0x65, 0x03, 0x6b, 0xe5, 0x05, 0x6e, 0xf4, 0x68,
    0x65, 0x06, 0xe6, 0x61, 0xf4, 0x68, 0x65, 0x06, 0x65, 0x69, 0xf4, 0x68,
    0x65, 0x04, 0x74, 0x68, 0xe5, 0x04, 0x73, 0x68, 0xe5, 0x04, 0xf0, 0x68,
    0x65, 0x04, 0x63, 0x68, 0xe5, 0x04, 0x64, 0x67, 0xe5, 0x04, 0x72, 0x64,
    0xe5, 0x06, 0x6f, 0x75, 0x6e, 0x64, 0xe5, 0x04, 0x6c, 0x64, 0xe5, 0x04,
    0x69, 0x64, 0xe5, 0x05, 0xe4, 0x75, 0x63, 0xe5, 0x04, 0x6e, 0x63, 0xe5,
    0x42, 0xe5, 0x03, 0xf3, 0x61, 0x26, 0x61, 0x63, 0xf5, 0xec, 0x61, 0x26,
    0x65, 0x63, 0xf5, 0xec, 0x61, 0x26, 0x69, 0x63, 0xf5, 0xec, 0x61, 0x26,
    0x65, 0x67, 0xf5, 0xec, 0x61, 0x00, 0x24, 0x75, 0xef, 0x75, 0x05, 0xf4,
    0x69, 0x6f, 0x75, 0x05, 0xe7, 0x69, 0x6f, 0x75, 0x05, 0xe3, 0x69, 0x6f,
    0x75, 0x24, 0x69, 0xef, 0x75, 0x05, 0xe7, 0x65, 0x6f, 0x75, 0x05, 0xe3,
    0x65, 0x6f, 0x75, 0x04, 0x65, 0xef, 0x75, 0x62, 0xf5, 0x04, 0xee, 0x65,
    0x73, 0x04, 0xec, 0x65, 0x73, 0x62, 0xf3, 0x25, 0x70, 0xef, 0xec, 0x69,
    0x62, 0xe9, 0x43, 0xf8, 0x65, 0x43, 0xf3, 0x65, 0x44, 0x73, 0x68, 0xe5,
    0x44, 0x63, 0x68, 0xe5, 0xc1, 0x00, 0x06, 0x69, 0x6f, 0x6e, 0xe9, 0x73,
    0x05, 0x69, 0x6e, 0xe9, 0x73, 0x05, 0x61, 0x6c, 0xe9, 0x73, 0x06, 0x6c,
    0xef, 0xe7, 0x69, 0x73, 0x05, 0x68, 0x74, 0xe5, 0x73, 0x04, 0x69, 0xe5,
    0x73, 0x05, 0x67, 0xe7, 0x65, 0x73, 0x04, 0x67, 0xe5, 0x73, 0x05, 0x64,
    0xe4, 0x65, 0x73, 0x04, 0x64, 0xe5, 0x73, 0x04, 0xe3, 0x61, 0x73, 0x05,
    0xe8, 0x65, 0x61, 0x72, 0x04, 0xe6, 0x6f, 0x6f, 0x03, 0x69, 0xef, 0x05,
    0xe6, 0x72, 0x6f, 0x6e, 0x05, 0xf0, 0x72, 0x69, 0x6e, 0x04, 0xed, 0x65,
    0x6e, 0x05, 0xe3, 0x69, 0x65, 0x6e, 0x04, 0x69, 0xe1, 0x6e, 0x06, 0xf7,
    0x72, 0x69, 0x67, 0x68, 0x06, 0xe2, 0x72, 0x69, 0x67, 0x68, 0x06, 0xe6,
    0x6c, 0x69, 0x67, 0x68, 0x06, 0xf7, 0x65, 0x69, 0x67, 0x68, 0x05, 0xf3,
    0x68, 0x69, 0x66, 0x05, 0xe3, 0x72, 0x61, 0x66, 0x24, 0x64, 0x67, 0xe5,
    0x04, 0xe7, 0x6f, 0x61, 0x04, 0xe3, 0x6f, 0x61, 0x04, 0xe2, 0x6f, 0x61,
    0x04, 0xf7, 0x68, 0x61, 0x04, 0xe3, 0x75, 0x69, 0x00, 0x24, 0x65, 0x73,
    0xf4, 0x25, 0x71, 0x75, 0x69, 0xf4, 0x04, 0xf4, 0x69, 0xf4, 0x25, 0x6f,
    0x73, 0xe9, 0xf4, 0x04, 0xf3, 0x69, 0xf4, 0x05, 0x69, 0x6e, 0xe9, 0xf4,
    0x04, 0x6e, 0x69, 0xf4, 0x28, 0x66, 0x61, 0xe2, 0x69, 0x6c, 0xe9, 0xf4,
    0x08, 0xe3, 0x61, 0xe2, 0x69, 0x6c, 0xe9, 0xf4, 0x08, 0xf0, 0x61, 0xe2,
    0x69, 0x6c, 0xe9, 0xf4, 0x06, 0xe2, 0x69, 0x6c, 0xe9, 0xf4, 0x03, 0x69,
    0xf4, 0x04, 0xe2, 0x75, 0x72, 0x04, 0xf4, 0x6f, 0xf2, 0x05, 0xf1, 0x75,
    0x61, 0x72, 0x24, 0x75, 0xe1, 0x72, 0x07, 0xed, 0x65, 0x6e, 0xf4, 0x61,
    0xf2, 0x06, 0x69, 0x6f, 0x6e, 0xe1, 0x72, 0x04, 0x69, 0xe1, 0x72, 0x04,
    0x6e, 0xef, 0xed, 0x03, 0xf0, 0x6c, 0x04, 0x67, 0xe7, 0x6c, 0x05, 0xf0,
    0x61, 0xe2, 0x6c, 0x05, 0x66, 0x61, 0xe2, 0x6c, 0x05, 0xe3, 0x61, 0xe2,
    0x6c, 0x04, 0xe1, 0x62, 0x6c, 0x03, 0xe2, 0x6c, 0x02, 0xec, 0x03, 0xf3,
    0x6b, 0x26, 0x67, 0xf2, 0x61, 0xf0, 0x68, 0x04, 0x6c, 0xef, 0xe7, 0x02,
    0xe6, 0x03, 0xee, 0x65, 0x03, 0xec, 0x65, 0x04, 0x63, 0x6b, 0xe5, 0x03,
    0xeb, 0x65, 0x04, 0xe2, 0x6f, 0x64, 0x05, 0xf3, 0x74, 0x75, 0x64, 0xe4,
    0x65, 0x65, 0x64, 0x02, 0xe2
};

/**
 * @brief Validates if the given letter index is within the valid range (0-25 for a-z).
 * @param letter_idx The index of the letter (0 for 'a', 25 for 'z').
 * @return Non-zero (true) if the letter index is valid, 0 (false) otherwise.
 */
static int suftab_validate_letter(int letter_idx)
{
    return (letter_idx >= 0 && letter_idx < SUFTAB_INDEX_SIZE);
}

/**
 * @brief Gets the byte offset into @c suftab_bytes for a given letter index.
 * @param letter_idx The index of the letter (0 for 'a', 25 for 'z').
 * @return The byte offset if the letter index is valid and has entries,
 *         otherwise 0.
 */
static unsigned short suftab_get_offset(int letter_idx) /* Return type changed */
{
    if (!suftab_validate_letter(letter_idx)) {
        return 0;
    }
    return suftab_index[letter_idx];
}

/**
 * @brief Retrieves a pointer to a specific suffix entry within the @c suftab_bytes array.
 *
 * This function navigates the suffix entries starting from the given offset
 * to find the entry specified by @p entry_num.
 *
 * @param start_offset The byte offset in @c suftab_bytes where the entries for a
 *                     particular letter begin. This should be a valid offset obtained
 *                     from @c suftab_index.
 * @param entry_num The 0-based index of the desired suffix entry within the
 *                  block of entries for the letter.
 * @return A const pointer to the first byte (length/flags byte) of the
 *         requested suffix entry if found and valid.
 *         Returns @c NULL if @p start_offset is 0, if @p entry_num is out of bounds,
 *         if an invalid entry (e.g., zero length) is encountered prematurely,
 *         or if the entry would extend beyond the bounds of @c suftab_bytes.
 *
 * @note The caller must not attempt to modify the memory pointed to by the
 *       returned pointer.
 * @warning This function relies on the integrity of the @c suftab_bytes data.
 *          Corrupted data (e.g., incorrect lengths) can lead to undefined behavior.
 */
static const unsigned char *suftab_get_entry_ptr(unsigned short start_offset, int entry_num)
{
    const unsigned char *ptr;
    const unsigned char *end_of_table;
    int current_entry_idx;
    int entry_len;

    if (start_offset == 0) { /* No entries for this letter or invalid offset */
        return NULL;
    }

    ptr = &suftab_bytes[start_offset];
    end_of_table = suftab_bytes + sizeof(suftab_bytes);
    current_entry_idx = 0;

    /* Traverse entries to find the one at entry_num */
    while (current_entry_idx < entry_num) {
        if (ptr >= end_of_table) { /* Check before dereferencing ptr */
            return NULL; /* Reached end of table prematurely */
        }
        entry_len = suftab_get_entry_length(ptr);
        if (entry_len == 0) {
            /* Found a zero-length entry, which typically marks the end of entries for a letter,
             * or it's an invalid entry if not the one we are looking for.
             */
            return NULL; /* Target entry_num not reached before end marker */
        }
        /* Move to the next entry: +1 for the length/flags byte itself */
        ptr += entry_len + 1;
        current_entry_idx++;
    }

    /* After the loop, ptr should point to the start of the entry_num-th entry,
     * or have passed it if entry_num was too large.
     */
    if (current_entry_idx == entry_num) {
        if (ptr < end_of_table) { /* Ensure the entry itself is within bounds */
             /* Check if the entry's own length byte indicates a valid entry */
            if (suftab_get_entry_length(ptr) > 0 || 
                (suftab_has_break_flag(ptr) || suftab_has_priority_flag(ptr))) { /* Allow zero-length if flags are set */
                 /* Further check: ensure the full entry does not exceed table bounds */
                entry_len = suftab_get_entry_length(ptr);
                if (ptr + entry_len + 1 <= end_of_table) {
                    return ptr;
                }
            } else if (suftab_get_entry_length(ptr) == 0 && entry_num == current_entry_idx) {
                /* If we are looking for an entry that happens to be a zero-length marker,
                   and it's the one we stopped at, it might be considered valid in some contexts,
                   but typically suftab_lookup would stop processing at such an entry.
                   For get_entry_ptr, if it's a terminal zero-length entry, it's not a "findable" pattern.
                   However, the original code might have implicitly handled this.
                   Let's assume a zero-length entry without flags is not a valid target unless it's the *only* entry.
                   The loop condition `entry_len == 0` handles termination.
                   If we land here, it means we are at the requested index.
                */
                 if (suftab_bytes[start_offset] == 0 && entry_num == 0) return ptr; /* Special case: first entry is null marker */
            }
        }
    }
    
    /* If entry_num was not found, or if ptr is out of bounds */
    return NULL;
}


/**
 * @brief Extracts the length of the suffix pattern from its entry header byte.
 * @param entry_ptr Pointer to the first byte (length/flags byte) of a suffix entry.
 *                  Must not be @c NULL.
 * @return The length of the suffix pattern (0-63).
 *         Returns 0 if @p entry_ptr is @c NULL (though this should be guarded by caller).
 */
static int suftab_get_entry_length(const unsigned char *entry_ptr)
{
    if (entry_ptr == NULL) {
        return 0; /* Defensive check */
    }
    return (int)(*entry_ptr & SUFTAB_LENGTH_MASK);
}

/**
 * @brief Checks if a suffix entry has the "allow break before" flag set.
 * @param entry_ptr Pointer to the first byte (length/flags byte) of a suffix entry.
 *                  Must not be @c NULL.
 * @return Non-zero (true) if the break flag is set, 0 (false) otherwise.
 *         Returns 0 if @p entry_ptr is @c NULL.
 */
static int suftab_has_break_flag(const unsigned char *entry_ptr)
{
    if (entry_ptr == NULL) {
        return 0; /* Defensive check */
    }
    return (*entry_ptr & SUFTAB_BREAK_FLAG) ? 1 : 0;
}

/**
 * @brief Checks if a suffix entry has the "priority marker" flag set.
 * @param entry_ptr Pointer to the first byte (length/flags byte) of a suffix entry.
 *                  Must not be @c NULL.
 * @return Non-zero (true) if the priority flag is set, 0 (false) otherwise.
 *         Returns 0 if @p entry_ptr is @c NULL.
 */
static int suftab_has_priority_flag(const unsigned char *entry_ptr)
{
    if (entry_ptr == NULL) {
        return 0; /* Defensive check */
    }
    return (*entry_ptr & SUFTAB_PRIORITY_FLAG) ? 1 : 0;
}

/* Public interface functions */

/**
 * @brief Looks up all suffix patterns for a given letter and invokes a callback
 *        for each pattern found.
 *
 * Iterates through all suffix entries in @c suftab_bytes associated with the
 * specified @p letter. For each valid suffix entry, it extracts the pattern,
 * length, and flags, then calls the provided @p callback function.
 *
 * @param letter The letter (a-z, case-insensitive) for which to look up suffixes.
 * @param callback A function pointer of type @c suftab_callback_t. This function
 *                 will be called for each suffix pattern found. It receives:
 *                 - @c const unsigned char* (pointer to the pattern characters)
 *                 - @c int (length of the pattern)
 *                 - @c int (flags associated with the pattern)
 *                 - @c void* (the @p user_data passed to @c suftab_lookup)
 *                 If @c NULL, patterns are counted but no callback is made.
 * @param user_data A void pointer to user-defined data that will be passed
 *                  through to the @p callback function.
 *
 * @return The number of suffix patterns found and processed for the given letter.
 *         Returns -1 if the input @p letter is invalid.
 *         Returns 0 if the letter is valid but has no suffix entries.
 *
 * @note Processing stops if a zero-length entry is encountered, as this typically
 *       marks the end of entries for a letter.
 */
int suftab_lookup(int letter, suftab_callback_t callback, void *user_data)
{
    int letter_idx;
    unsigned short offset; /* Changed type */
    const unsigned char *ptr;
    const unsigned char *end_ptr;
    int count;
    int entry_len;
    int flags;

    /* Convert letter to 0-25 index */
    if (letter >= 'A' && letter <= 'Z') {
        letter_idx = letter - 'A';
    } else if (letter >= 'a' && letter <= 'z') {
        letter_idx = letter - 'a';
    } else {
        return -1; /* Invalid letter input */
    }

    if (!suftab_validate_letter(letter_idx)) { /* Should not happen if above logic is correct */
        return -1; /* Should be caught by previous check, but good for safety */
    }

    offset = suftab_get_offset(letter_idx);
    if (offset == 0) {
        return 0; /* No entries for this letter */
    }

    ptr = &suftab_bytes[offset];
    /* Calculate end_ptr relative to the start of suftab_bytes to prevent overflow if offset is large,
     * though suftab_init should validate offsets.
     */
    end_ptr = suftab_bytes + sizeof(suftab_bytes);
    count = 0;

    /* Process all entries for this letter */
    while (ptr < end_ptr) {
        entry_len = suftab_get_entry_length(ptr);
        if (entry_len == 0) {
            /* A zero-length entry marks the end of the list for this letter.
             * However, it could theoretically have flags. The original code implies
             * a simple zero length is a terminator.
             * If it has flags, it might be a special case, but typically processing stops.
             * Let's assume standard behavior: zero length (without flags) terminates.
             * If it has flags but zero length, it's an unusual case.
             * The loop `ptr < end_ptr` and `ptr + entry_len + 1 <= end_ptr` (implicit in next step)
             * are the primary boundary checks.
             */
            if (!suftab_has_break_flag(ptr) && !suftab_has_priority_flag(ptr)) {
                 break; /* End of entries for this letter if no flags */
            }
            /* If it has flags, it's a zero-length suffix with special properties. Process it. */
        }

        /* Ensure the full entry (header + pattern) is within bounds */
        if (ptr + entry_len + 1 > end_ptr) {
            /* This indicates corrupted data or an issue with the last entry. */
            /* Optionally, log an error here. */
            break; /* Avoid reading out of bounds. */
        }

        /* Extract flags */
        flags = 0;
        if (suftab_has_break_flag(ptr)) {
            flags |= SUFTAB_BREAK_FLAG;
        }
        if (suftab_has_priority_flag(ptr)) {
            flags |= SUFTAB_PRIORITY_FLAG;
        }

        /* Call callback with pattern data (ptr + 1 points to the pattern itself) */
        if (callback != NULL) {
            callback(ptr + 1, entry_len, flags, user_data);
        }

        count++;
        ptr += entry_len + 1; /* Move to next entry */
    }

    return count;
}

/**
 * @brief Gets the total size in bytes of the @c suftab_bytes data array.
 * @return The size of the suffix byte data table.
 */
size_t suftab_get_size(void)
{
    return sizeof(suftab_bytes);
}

/**
 * @brief Gets the size of the @c suftab_index array (number of letters, a-z).
 * @return The number of elements in the suffix index table (always @c SUFTAB_INDEX_SIZE).
 */
int suftab_get_index_size(void)
{
    return SUFTAB_INDEX_SIZE;
}

/**
 * @brief Initializes and validates the suffix table module.
 *
 * This function performs basic validation checks on the suffix table data
 * structures, such as ensuring the index size is correct and that all
 * offsets in @c suftab_index are within the bounds of @c suftab_bytes.
 *
 * @return 0 on successful validation.
 * @return -1 if a validation check fails, indicating a potential issue with
 *         the compiled-in suffix data (e.g., incorrect array sizes or
 *         out-of-bounds offsets).
 *
 * @note This function should be called once during the application's
 *       initialization phase before any other @c suftab functions are used.
 */
int suftab_init(void)
{
    int i; /* C90: Declare variables at the start of the block */

    /* Basic validation of data structures */
    if ((sizeof(suftab_index) / sizeof(suftab_index[0])) != SUFTAB_INDEX_SIZE) {
        /* This check is somewhat redundant if SUFTAB_INDEX_SIZE is used
         * in the array declaration, but good for sanity.
         */
        return -1; /* Mismatch in expected vs actual index size */
    }

    /* Validate that all offsets in suftab_index are within bounds of suftab_bytes */
    for (i = 0; i < SUFTAB_INDEX_SIZE; i++) {
        /* An offset of 0 is valid (means no entries for that letter).
         * Any non-zero offset must be less than the total size of suftab_bytes.
         * It cannot be equal, because even an empty list of suffixes for a letter
         * that has an offset would point to a zero-length marker *within* the table.
         * If suftab_index[i] points to sizeof(suftab_bytes), it's out of bounds.
         */
        if (suftab_index[i] != 0 && suftab_index[i] >= sizeof(suftab_bytes)) {
            return -1; /* Offset is out of bounds */
        }
        /* Additional check: if offset is non-zero, it should point to a valid entry
         * or a zero-length marker. This is harder to check exhaustively here without
         * parsing, but suftab_lookup handles malformed entries.
         * The primary check is that the offset itself is valid.
         */
    }
    return 0; /* Initialization and validation successful */
}
